import 'package:code_builder/code_builder.dart';
import 'package:meta/meta.dart';
import 'package:web_idl/web_idl.dart';

import 'type_converter.dart';

class SourceGenerator {
  SourceGenerator(this.types);

  final TypeConverter types;

  /// Create a [Library] from a [FragmentElement].
  Library library(FragmentElement element) => Library(
        (l) => l
          ..generatedByComment = 'Generated by Rampage on ${DateTime.now()}'
          ..body.addAll(
            [
              ...element.dictionaries.where(_isConcrete).expand(dictionary),
              ...element.enumerations.expand(enumeration),
              ...element.functions.expand(function),
              ...element.interfaces.where(_isConcrete).expand(interface),
              ...element.namespaces.where(_isConcrete).expand(namespace),
              ...element.typeDefinitions.expand(typeDefinition),
            ],
          ),
      );

  /// Create a [Spec] from a [DictionaryElement].
  ///
  /// The actual return type of the method is dependent on
  /// Returns an empty [Code] block if the [element] is not supported.
  @protected
  Iterable<Spec> dictionary(DictionaryElement element) => _empty;

  /// Create a [Spec] from a [EnumElement].
  ///
  /// Returns an empty [Code] block if the [element] is not supported.
  @protected
  Iterable<Spec> enumeration(EnumElement element) => _empty;

  /// Create a [Spec] from a [FunctionTypeAliasElement].
  ///
  /// Returns an empty [Code] block if the [element] is not supported.
  @protected
  Iterable<Spec> function(FunctionTypeAliasElement element) => _empty;

  /// Create a [Spec] from a [InterfaceElement].
  ///
  /// Returns an empty [Code] block if the [element] is not supported.
  @protected
  Iterable<Spec> interface(InterfaceElement element) => _empty;

  /// Create a [Spec] from a [NamespaceElement].
  ///
  /// Returns an empty [Code] block if the [element] is not supported.
  @protected
  Iterable<Spec> namespace(NamespaceElement element) => _empty;

  /// Create a [Spec] from a [TypeAliasElement].
  @protected
  Iterable<Spec> typeDefinition(TypeAliasElement element) => _empty;

  static const _empty = <Code>[Code('')];

  static bool _isConcrete(PartiallyDefinedElement element) =>
      !element.isPartial;
}
