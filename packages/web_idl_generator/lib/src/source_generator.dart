// Copyright (c) 2025 the Rampage Project Authors.
// Please see the AUTHORS file for details. All rights reserved.
// Use of this source code is governed by a zlib license that can be found in
// the LICENSE file.

import 'package:code_builder/code_builder.dart';
import 'package:meta/meta.dart';
import 'package:web_idl/web_idl.dart';

import 'type_converter.dart';

abstract class SourceGenerator {
  @protected
  late TypeConverter types;

  /// Create a [Library] from a [FragmentElement].
  Library library(FragmentElement element, {TypeMap? mapping}) {
    types = typeConverter(mapping);
    return Library(
      (l) =>
          l
            ..generatedByComment = 'Generated by Rampage on ${DateTime.now()}'
            ..directives.addAll(directives())
            ..body.addAll([
              ...element.dictionaries.where(_isConcrete).expand(dictionary),
              ...element.enumerations.expand(enumeration),
              ...element.functions.expand(function),
              ...element.interfaces.where(_isConcrete).expand(interface),
              ...element.namespaces.where(_isConcrete).expand(namespace),
              ...element.typeDefinitions.expand(typeDefinition),
            ]),
    );
  }

  @protected
  TypeConverter typeConverter(TypeMap? mapping);

  @protected
  Iterable<Directive> directives() => const Iterable<Directive>.empty();

  /// Create a [Spec] from a [DictionaryElement].
  ///
  /// The actual return type of the method is dependent on
  /// Returns an empty [Code] block if the [element] is not supported.
  @protected
  Iterable<Spec> dictionary(DictionaryElement element) => _empty;

  /// Create a [Spec] from a [EnumElement].
  ///
  /// Returns an empty [Code] block if the [element] is not supported.
  @protected
  Iterable<Spec> enumeration(EnumElement element) => _empty;

  /// Create a [Spec] from a [FunctionTypeAliasElement].
  ///
  /// Returns an empty [Code] block if the [element] is not supported.
  @protected
  Iterable<Spec> function(FunctionTypeAliasElement element) => _empty;

  /// Create a [Spec] from a [InterfaceElement].
  ///
  /// Returns an empty [Code] block if the [element] is not supported.
  @protected
  Iterable<Spec> interface(InterfaceElement element) => _empty;

  /// Create a [Spec] from a [NamespaceElement].
  ///
  /// Returns an empty [Code] block if the [element] is not supported.
  @protected
  Iterable<Spec> namespace(NamespaceElement element) => _empty;

  /// Create a [Spec] from a [TypeAliasElement].
  @protected
  Iterable<Spec> typeDefinition(TypeAliasElement element) => _empty;

  static const _empty = <Code>[Code('')];

  static bool _isConcrete(PartiallyDefinedElement element) =>
      !element.isPartial;
}
